<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Vue - Infos</title>
</head>

<body>

  1) Yukleme -

  npm create vue@latest

  Burada ozu sorusacaqki typescript olsun yoxsa yox.Routingi true sec ki defolt olaraq
  versin.

  Yuklendikden sonra ise bele:

  npm install
  npm run format
  npm run dev

  Hele ki en son verisya 3.2 dir

  npm run dev ile ise salinir ve http://localhost:5173 portunda acir.

  Link: https://vuejs.org/guide/quick-start.html#creating-a-vue-application

  2)
  <RouterView /> - app da yer alir, children kimidir, sehifede gelenler burada gelir,
  Layout sistemi ise app da qurulur.Kenarda da qurmaq olar.

  3) Routing ve sehifeler -

  src/router/index.ts aciriq sehifeler ucun komponentler ve onlar ucun sehife adlari
  burada yazilir.Sehifeler ise src/views qovluqunda component kimi yer alir.
  Adi komponentler ise src/components qovluqundadir.

  Slug sehifesi yaratma:

  {
  path: '/examples/:slug',
  name: 'example',
  component: ExampleSlugView
  },

  Sehifede slug alma:

  <script>

    export default {
      data() {
        return {
          content: ''
        };
      },
      created() {
        // You can fetch data based on the slug parameter here
        const slug = this.$route.params.slug;
        // Example: Fetch content using an API
        // Replace this with your actual data fetching logic
        this.fetchContent(slug);
      },
      methods: {
        fetchContent(slug) {
          // Simulate fetching content based on the slug
          // Replace this with your actual data fetching logic
          this.content = `Content for slug: ${slug}`;
        }
      }
    };
  </script>

  data - komponentin propertyleri ucundur, defolt olaraq deyer de vere bilirsen burada

  created - lifecycle hook sayilir.Komponent instance yarandiqda ve DOMA mount olmazdan
  qabaq ise dusur.Adeten data cekmek ve bu formada olan seyler ucun istifade olunur.

  methods - buraya komponent ucun olan metodlarimiz yazilir.

  Burada js html icerisinde iki moterize ile yazilir:

  <p>{{ content }}</p>

  4) Component - HTML template, style ise style tag arasinda yazilir.

  style arasinda yazilan stil butun sehifeye tesir edir, meselen .example classi olan
  basqalari da bunu qebul edecek.Bunu qarsini almaq ucun scoped tagi add etmek lazimdir
  buraya.

  <template>

    <div class="example">
      <h1>This is an example page</h1>
    </div>

  </template>

  <style scoped>
    .example {
      display: block !important;
      background-color: red;
      color: white;
    }
  </style>

  defineProps - burada komponentin qebul edeceyin propertyler yazilir, obyekt formasinda.

  <script setup lang="ts">
    defineProps < {
      name: string,
      description: string;
    } > ()
  </script>

  5) v-for dongusu:

  <ul>
    <Card v-for="(item, index) in items" :key="index" :name="item.name" :description="item.description" />
  </ul>

  6) Melumatlar -

  https://vuejs.org/guide/essentials/template-syntax.html#text-interpolation

  1 - text yazdirma:

  Adi text kimi (bu moterizeye Mustaches deyilir)
  <p>Using text interpolation: {{ rawHtml }}</p>

  HTML kimi
  <p>Using v-html directive: <span v-html="rawHtml"></span></p>

  2 - Attributa deyer vermek - burada Mustaches istifade ede bilmerik

  <div v-bind:id="dynamicId"></div>

  v-bind qisa formasi
  <div :id="dynamicId"></div>

  Butun attributlari obyekt kimi vere bilersen

  <script>

    const objectOfAttrs = {
      id: 'container',
      class: 'wrapper'
    }

  </script>

  <div v-bind="objectOfAttrs"></div>

  3 - Directives

  v- ile baslayan attributlar directives sayilir

  v-if false qoysan element dom dan silinecek

  <p v-if="seen">Now you see me</p>

  on click ve qisa yolu v-on eventler ucundur
  <a v-on:click="doSomething"> ... </a>

  <a @click="doSomething"> ... </a>

  4 - Modifiers

  prevent default etmeyin qisa yolu

  <form @submit.prevent="onSubmit">...</form>

  https://vuejs.org/guide/essentials/template-syntax.html#directives


  7) Declaring Reactive State -

  ref() - reactive stateler yaratmaq ucun tovsiye olunan bir yoldur.Valueni arqument
  olaraq goturur ve onu obj.value kimi qaytarir.

  <script>

    import { ref } from 'vue'

    const count = ref(0)

    console.log(count) // { value: 0 }
    console.log(count.value) // 0

    count.value++
    console.log(count.value) // 1

  </script>

  refleri setup icerisinde yaratmaq lazimdir

  <script>

    import { ref } from 'vue'

    export default {
      // `setup` is a special hook dedicated for the Composition API.
      setup() {
        const count = ref(0)

        // expose the ref to the template
        return {
          count
        }
      }
    }

  </script>

  setupu yuxari da yaza bilersen

  <script setup>
    import { ref } from 'vue'

    const count = ref(0)

    function increment() {
      count.value++
    }
  </script>


  - diger bir yolu ise reactive istifade etmekdir - bu obyektin ozunu duzeldir ele daha
  value icerisinde vermir.Reactive yalniz obyekt qebul edir, ref ise hamisini

  <script>
    import { reactive } from 'vue'
    const state = reactive({ count: 0 })
  </script>

  <button @click="state.count++">
    {{ state.count }}
  </button>

  Reactive state o demekdir ki, bu data deyisdikde sehifede lazim olan yer update olur.

  Composition API - Vue 3 ile gelib ve Options API ye alternativdir.Options API Vue 2 ye
  aiddir.

  Options API

  <template>
    <div>{{ message }}</div>
  </template>

  <script>
    export default {
      data() {
        return {
          message: 'Hello, Vue!'
        };
      }
    };
  </script>

  Composition Api

  <template>
    <div>{{ message }}</div>
  </template>

  <script setup>
    import { ref } from 'vue';

    const message = ref('Hello, Vue!');
  </script>

  Composition Api daha rahatdir ve ozellikleri var

  1 - Modularization
  2 - Reactivity Logic
  3 - Better TypeScript Support
  4 - Code Organization

  7) Computed Properties -

  Link: https://vuejs.org/guide/essentials/computed.html#basic-example

  8) Lifecycle Hooks -

  onMounted - useEffect kimi

  <script setup>

    import { onMounted } from 'vue'

    onMounted(() => {
      console.log(`the component is now mounted.`)
    })

  </script>

  onUpdated() - update olduqda, meselen her hansi bir state deyisse.useEffect dependency
  deyisen kimi.

  <script setup>
    import { ref, onUpdated } from 'vue'

    const count = ref(0)

    onUpdated(() => {
      // text content should be the same as current `count.value`
      console.log(document.getElementById('count').textContent)
    })
  </script>

  onUnmounted() - komponent silinende - useEffect return kimi

  <script setup>
    import { onMounted, onUnmounted } from 'vue'

    let intervalId
    onMounted(() => {
      intervalId = setInterval(() => {
        // ...
      })
    })

    onUnmounted(() => clearInterval(intervalId))
  </script>

  onBeforeMount() - mount olmazdan qabaq isleyir server-sdie terefde calismir.

  onBeforeUpdate() - updateden once bas verir.

  onBeforeUnmount() - unmountdan once bas verir.

  onErrorCaptured() - error gorulduyu zaman calisir.Error bunlardan ireli gele biler.

  Component renders
  Event handlers
  Lifecycle hooks
  setup() function
  Watchers
  Custom directive hooks
  Transition hooks

  Link: https://vuejs.org/guide/essentials/lifecycle.html

  Link: https://vuejs.org/api/composition-api-lifecycle.html

  <!-- https://vuejs.org/guide/essentials/lifecycle.html -->









  Link: https://vuejs.org/guide/essentials/reactivity-fundamentals.html#why-refs


  8) Computed Properties - reactda ki useMemo kimidir, lazimsiz renderlerden qacmaq ucun.

  Asagida olan computedValue ve publishedBooksMessage artiq statelerden asilidir, yeni her renderde
  yeniden yaranmayacaq ve yalniz aid oldugu state deyisdiyi zaman yeniden yaranacaq.Bu memoization
  deyil computed properties ve yaxud Computed Caching adlanir, amm mentiqi eynidir.Bunu hemcinin
  watch ile de etmek olur Vue de.Bunlar ozleri hansi reactive stateye aid olduqlarini avtomatik
  bilirler ve yalniz onun deyeri deyisdikde yeniden isleyirler, bele ise cashed olunmus
  deyer istifade edirler.Uzun kalkulyatorlar da bu cox faydalidir.

  <script setup lang="ts">

    import Card from '../components/cards/Card.vue'

    import { ref } from 'vue';

    const count = ref(0)

    function increment() {
      count.value++
    }

    function decrease() {
      count.value--
    }

    import { reactive, computed } from 'vue'

    const computedValue = computed(() => count.value * 2);

    const state = reactive({ count: 0 })

    const author = reactive({
      name: 'John Doe',
      books: [
        'Vue 2 - Advanced Guide',
        'Vue 3 - Basic Guide',
        'Vue 4 - The Mystery'
      ]
    })

    const publishedBooksMessage = computed(() => {
      return author.books.length > 0 ? 'Yes' : 'No'
    })

  </script>

  Yuxaridakini bele bir funksiya ile de ede bilerdik lakin her render zamani
  bu yeniden niye calissin ki ? Netice eyni olur, sadece artiq rendere ehtiyac yoxdur.

  <script>
    function calculateBooksMessage() {
      return author.books.length > 0 ? 'Yes' : 'No'
    }
  </script>

  Link: https://vuejs.org/guide/essentials/computed.html#basic-example

  9) Watchers - Mentiqi computed ile eyndir (amma bu meoization etmir, update olduqda is gormek
  ucundur), lakin bezen biz stateni deyisdikde side effekler
  etmeyimize ehtiyac olur, meselen statenin bir hissesinin deyisilmesi kimi.

  Computed ile esas ferqi odur ki, computed read-only sayilir ve statenin ozunu deyise bilmir,
  watch ise deyise bilir.Watch sanki update gozleyib, stateni updateye uygun deyisir ve yeno ve kohne
  stateni parametr kimi alir.

  Burada bir statenin deyismesinden asili olaraq mueyyen side effekleri istifade ede bilirk,
  eynile reactda useEffecte stateni dependency vermek kimi.

  Burada count her defe deyisdikde, doubleCount da onun deyisen deyerine gore deyer verecek.
  newCount parametri countun yeni deyeridir.oldCount ise kohne deyeri verir.Avtomatik verilen
  parametrlerdir.Computed yanliz deyer qaytarir.

  <script>
    const count = ref(0);
    const doubleCount = ref(0);

    watch(count, (newCount, oldCount) => {
      doubleCount.value = newCount * 2;
    });


  </script>

  Watch lazy davranir, yeni state deyismemis icerisinde verdiklerimiz hesablanmir.Amma
  ele bir hal ola biler ki state deyismemis initial olaraq da hesablayib gostermesini isteyerik,
  bu halda inmediate true etmeliyik.

  Asagidaki halda doubleCount sehife acilan kimi 0 gelmeyecek, derhal stateye vurub hesablayib
  bize verecek, state hele deyismemis initial olaraq.Eger true qoymasa idik, ilk basda 0 verecekdi,
  sonra state deyisende deyer verecekdi.

  <script>
    const doubleCount = ref(0);

    watch(count, (newCount, oldCount) => {
      doubleCount.value = newCount * 2;
    }, { immediate: true });
  </script>

  watchEffect - her ikisini evezleyir, bu halda hem dependency vermeye ehtiyac yoxdur, hem de
  inmediateL true;Computed propertiesler kimi dependency i avtomatik olaraq goturur ve lazy islemir.
  Aralarindaki ferq boyuk deyil.Feriq yalniz qeyd olunanlardadir, derhal icra olmasi ve
  dependency vermeyin lazim olmamasi.

  Bunlar hamisi Watchers sayilir.

  Bunlarin funksiya hissesi callback adlanir.

  watch vs. watchEffectâ€‹
  watch and watchEffect both allow us to reactively perform side effects. Their main difference is the way they track
  their reactive dependencies:

  watch only tracks the explicitly watched source. It won't track anything accessed inside the callback. In addition,
  the callback only triggers when the source has actually changed. watch separates dependency tracking from the side
  effect, giving us more precise control over when the callback should fire.

  watchEffect, on the other hand, combines dependency tracking and side effect into one phase. It automatically tracks
  every reactive property accessed during its synchronous execution. This is more convenient and typically results in
  terser code, but makes its reactive dependencies less explicit.

  <script>
    watchEffect(async () => {
      doubleCount.value = count.value * 2;
    })
  </script>

  unwatch() - her ikisini dayandirmaq ucun istifade olunur.

  Bunlar hook deyil, watchers sayilir.Data da olan deyisikliklere reaksiya verib onlar uzerinde
  is gormek ucundurler.

  https://vuejs.org/guide/essentials/watchers.html

  10) <input v-model="question" /> - v-model directive sayilir.

  Bu inputa property verir value olaraq ve input valuesi here defe deyisdikde gedib hemin reactive
  stateni deyisdirir.

  11) Class and style bindings

  elave sertlere gore :class (v-bind:class qisa formasidir) obyeti oture bilerik, normal
  classlari da class icerisinde yaza bilerik.

  <script>
    const isActive = ref(true)
    const hasError = ref(false)
  </script>

  <div class="static" :class="{ active: isActive, 'text-danger': hasError }"></div>

  Bu fromada render olacaq

  <div class="static active"></div>


  Hetta kenarda bir obyekt kimi saxlayib da vere bilerik:

  <script>
    const classObject = reactive({
      active: true,
      'text-danger': false
    })
  </script>

  <div :class="classObject"></div>

  classi toggle etmek:

  <div :class="[isActive ? activeClass : '', errorClass]"></div>

  Parentden class otursen onu bele ($attrs.class) alirsan, daha ayrica className acmaga ehtiyac yoxdur.

  <p :class="$attrs.class">Hi!</p>

  inline style yazmaq olur:

  <div :style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>

  camelCase ile yazilmasi meslehetdir keylerin, amma string formasinda da yazmaq olar:

  <div :style="{ 'font-size': fontSize + 'px' }"></div>

  styleni obyekt kimi, hemde icinde obyeltler olan array kimi de ver bilersen

  iki obyekt -
  <div :style="[baseStyles, overridingStyles]"></div>

  bir obyekt -
  <div :style="styleObject"></div>

  Link: https://vuejs.org/guide/essentials/class-and-style.html#binding-html-classes

  12) Conditional Rendering:

  v-if - directive sayilir, true qayitsa render edir, qayitmasa etmir.Directiveler
  xususi attributlar sayilir ve HTML elementlere xususi behavior lar verir.

  v-else ise if ile islenir if false qayitsa v-else de olan gorunur

  <h1 v-if="awesome">Vue is awesome!</h1>
  <h1 v-else>Oh no ðŸ˜¢</h1>

  v-else-if - ise if den sonraki sertdir

  <div v-if="type === 'A'">
    A
  </div>

  <div v-else-if="type === 'B'">
    B
  </div>

  <div v-else-if="type === 'C'">
    C
  </div>

  <div v-else>
    Not A/B/C
  </div>

  w-show ile de elementi gosterib gizlemek olur, lakin bu element gizlense de DOM da olur,
  cunki yalniz display none olur, v-if de ise umumiyyetle render olmur.

  <h1 v-show="ok">Hello!</h1>

  Link: https://vuejs.org/guide/essentials/conditional.html

  13) List Rendering -

  v-for reactda ki map kimidir.Amma bu obyekti de donguye sala bilir.

  <script>

    const items = ref([{ message: 'Foo' }, { message: 'Bar' }])

    const myObject = reactive({
      title: 'How to do lists in Vue',
      author: 'Jane Doe',
      publishedAt: '2016-04-10'
    })

  </script>

  <li v-for="(value, key, index) in myObject" :key="index">
    {{ index }}. {{ key }}: {{ value }}
  </li>

  <li v-for="(item, index) in items" :key="index">
    {{ item.message }}
  </li>

  sintaksis olaraq in evezine of da yaza bilersen.

  <div v-for="item of items"></div>


  Link: https://vuejs.org/guide/essentials/list.html

  14) Event Handling - handler ler iki cur olur, inline ve method.Methodlar scriptden
  gelen hazir funksiyalardir, inline ise el ile yazilan;

  inline:
  <button @click="count++">Add 1</button>
  <p>Count is: {{ count }}</p>

  method:
  <button @click="greet">Greet</button>

  event modifiers -

  <!-- the click event's propagation will be stopped -->
  <a @click.stop="doThis"></a>

  <!-- the submit event will no longer reload the page -->
  <form @submit.prevent="onSubmit"></form>
  ve basqalari da var.

  LinK: https://vuejs.org/guide/essentials/event-handling.html

  15) Form Input Bindings -

  v-model ile inputla stateni baglamaq ve onsuz baglama:

  <input :value="text" @input="event => text = event.target.value">

  v-model ile
  <input v-model="text">

  Radioda selectde hamisinda v-model istifade olunur:

  <select v-model="selected">
    <option disabled value="">Please select one</option>
    <option>A</option>
    <option>B</option>
    <option>C</option>
  </select>

  <!-- `picked` is a string "a" when checked -->
  <input type="radio" v-model="picked" value="a" />

  <!-- `toggle` is either true or false -->
  <input type="checkbox" v-model="toggle" />

  <!-- `selected` is a string "abc" when the first option is selected -->
  <select v-model="selected">
    <option value="abc">ABC</option>
  </select>

  lazy qoysaq focusout olmasaq statenin ozunu deyismir, bu ise render sayini azaldir.

  <input v-model.lazy="msg" />

  Valuenin avtomatik number olmasi ucun:

  <input v-model.number="age" />

  Avtomatik trim olmasi ucun:

  <input v-model.trim="msg" />

  Link: https://vuejs.org/guide/essentials/forms.html

  16) Template Refs -

  ref attributdur ve Reactda oldugu kimi DOM elementine birbasa catmaq ucundur.
  .current evezine .value ile secirik.

  <script setup>
    import { ref, onMounted } from 'vue'

    // declare a ref to hold the element reference
    // the name must match template ref value
    const input = ref(null)

    onMounted(() => {
      input.value.focus()
    })
  </script>

  <template>
    <input ref="input" />
  </template>

  Link: https://vuejs.org/guide/essentials/template-refs.html

  17) Components Basics -

  defineProps(['title']) - props alma

  Card02 name="Hello World" description="Desc" />

  card ozu:

  <script setup lang="ts">
    defineProps < {
      name: string,
      description: string;
    } > ()
  </script>

  <template>

    <div class="card">

      <h3 class="name">{{name}}</h3>
      <p class="description">{{description}}</p>
    </div>

  </template>

  tre ile yazilan camel case ile yazilir:

  defineProps({
  greetingMessage: String
  })

  <MyComponent greeting-message="hello" /> camel case ile de yaza bilersen

  Link: https://vuejs.org/guide/essentials/component-basics.html

  18) i18n -

  Yukleme:

  npm install vue-i18n

  src/i18n qovluqu yaradiriq ve buraya az.json ve diger dilleri qoyuruq
  burada hemcinin index.js fayli yaradib dilleri buraya import edirik

  index.js
  <script>
    import en from './en.json';
    import de from './de.json';
    import az from './az.json';

    export default {
      az,
      en,
      de,
      // Add more language messages as needed
    };
  </script>

  main.ts da bunlari qoyuruq

  <script>
    import './assets/main.css'

    import { createApp } from 'vue'
    import App from './App.vue'
    import router from './router'

    // i18n
    import { createI18n } from 'vue-i18n';

    // i18n
    import messages from './i18n';

    // i18n
    const i18n = createI18n({
      locale: 'az',
      messages,
    });

    const app = createApp(App)

    app.use(router)

    // i18n
    app.use(i18n);

    app.mount('#app')

  </script>

  Bu formada istifade edirik - <p>{{ $t('welcome') }}</p>

  Dili ise bele deyisirik - this.$i18n.locale = 'de';

  Composition api de ferqli olur:

  bele import edirik
  <script>
    import { useI18n } from 'vue-i18n'; // Import useI18n from vue-i18n

    const { t, locale } = useI18n(); // Use useI18n to access i18n properties

    const changeLanguage = () => {
      alert(locale.value);
      locale.value = "de" // Change the locale to 'de'
    };
  </script>

  locale.value ile hem dili ala, hem de ki deyise bilirik.

  t ile istifade edib, setLocale ile deyisirik

  <button @click="changeLanguage">Change Language</button>
  <p>{{ t('welcome') }}</p>

  composition api de main.ts ya legacy add et

  <script>
    const i18n = createI18n({
      legacy: false,
      locale: 'az',
      messages,
    });
  </script>

  19) 404 page -

  <script>
    // router.js
    import { createRouter, createWebHistory } from 'vue-router';
    import NotFound from '@/views/NotFound.vue'; // Adjust the path accordingly

    const routes = [
      // ...your other routes
      // Define the catch-all route at the end
      { path: '/:catchAll(.*)', component: NotFound },
    ];

    const router = createRouter({
      history: createWebHistory(),
      routes,
    });

    export default router;

  </script>

  20) @ isaresi src folderin qisa yoludur -

  <script>
    import NotFound from '@/views/NotFound.vue'; // Adjust the path accordingly
  </script>

  21) env files -

  .env.production ve env.development fayli yarat
  adi VITE_API_KEY ile baslamalidir.

  VITE_API_KEY = 123-123-123-123

  cagiranda, composition api ucun:

  console.log(import.meta.env.VITE_API_KEY)

  https://www.youtube.com/watch?v=0PH9O88ytN8

  Link: https://cli.vuejs.org/guide/mode-and-env.html#environment-variables

  22) scss and sass -

  npm install sass --save-dev

  <style scoped lang="scss">
    $black: black;

    .example {
      display: block !important;
      background-color: red;
      color: white !important;
    }

    .scss-test {
      background-color: $black;
    }
  </style>

  Umumi ve komponent ucun scc cagirma:

  <link rel="stylesheet" href="src/assets/main.scss"> index.html ya atiriq,
  scoped olanlarin da klasslarina tesir edir

  <style src="../assets/component.scss" lang="scss" scoped></style>
  komponent daxilinde xarici scss cagirma

  23) Chakra for Vue JS -

  Yukleme:

  npm install @chakra-ui/vue @emotion/css

  main.js e add etme:

  <script>
    import Vue from 'vue'
    import Chakra, { CThemeProvider } from '@chakra-ui/vue'
    import App from './App.vue'

    Vue.use(Chakra)

    new Vue({
      el: '#app',
      render: (h) => h(CThemeProvider, [h(App)])
    }).$mount()
  </script>

  Link: https://vue.chakra-ui.com

  https://vue.chakra-ui.com/getting-started

  24) Vuex -

  Yukleme: npm install vuex@next --save

  Qosma:

  Isler: Store yaratdiq, burada statelerimiz ve mutationlarimiz olacaq.
  VuexView.vue ve store faylinda yer alib izahlar
  main.ts ya da elaveler alib

  module duzeltme: hamisi post ve store faylinda gosterilib

  Isleme mentiqi: Komponentden birbasa mutation olur ve yaxud action olur ve action mutationu isledir,
  sonra state deyisir, state ya birbasa komponente gedir ya da ki ondan sonra getters isleyir ve komponente stateni
  aparir.Komponentde yeniden
  mutation ve yauxd actionlar baslayaraq eyni dongunu tekrarlayir.

  sateler - statedir

  mutations - state deyismek ucun funksiyalardir.async ola bilmirler.

  actions - async ola bilerler ve bunlar mutationlari cagirirlar.

  getters - stateleri qaytarir, burada stateler uzerinde is gore bilerik, filter ve sair kimi
  meselen ancaq done olmus stateleri qaytara bilerik.

  modules - sadece bolgu ucundur, kodlar ayri yerde olsun deye.

  composition api de getters ve stateler computed olmalidir.

  <script>
    import { computed } from 'vue'
    import { useStore } from 'vuex'

    export default {
      setup() {
        const store = useStore()

        return {
          // access a state in computed function
          count: computed(() => store.state.count),

          // access a getter in computed function
          double: computed(() => store.getters.double)
        }
      }
    }
  </script>

  Link: https://vuex.vuejs.org/guide/

  25) axios -

  npm install axios --save

  26) emits - komponentlere emit ile funksiylara da oturule biler.Emit funksiyalari
  komponentden komponente oturmek ucundur.

  Funksiya props ile de oturule biler, valideyn komponent ile nese elaqesi olacaqsa
  eventin emit istifade etmek daha yaxsidir.

  bele oturursen
  <MyComponent @some-event="callback" />

  bele alirsan, $emit ile.Camel case meselesi burada da var.
  defineEmits ile emits mueyyen olunur.
  <script setup>
    defineEmits(['inFocus', 'submit'])
  </script>

  burada eger funksiyada istifade etmek isteyirikse emiti variableye beraber edirik.
  <script setup>
    const emit = defineEmits(['inFocus', 'submit'])

    function buttonClick() {
      emit('submit')
    }
  </script>

  1 paramterdir, string etsen tek dirnaq '' arasinda qoy
  <button @click="$emit('someEvent', 'ilham')">click me</button>

  Link: https://vuejs.org/guide/components/events.html#declaring-emitted-events

  27) slots - reactda ki children kimidir, slot komponent icinde children kimi yazilir ve
  komponent cagirilan yerde icerisinde oturulen kontent olur.

  slot icerisine fallback content qoyula bilir, eger hec bir kontent add olunmasa o gelir.

  slotu ad ile ayri-ayri da oturub cagira bilirik, sadece template icerisinde istifade
  edirik v-slot:name ve yaxud qisa yolla #name yaziri ve bunu slot name attributu ile komponentde
  istediyimiz yerde cagiririg. v-slot directive sayilir ve named slot ucun istifade olunur.

  <Card02 name="Hello World" description="Desc" first-greeting="Hellooo" @say-hello="sayHello"
    @say-goodbye="sayGoodbye">

    <p>I am slot</p>

    <template #myheader>
      <p>I am first header</p>
    </template>

  </Card02>

  <div class="card">

    <h3 class="name">{{name}}</h3>
    <p class="description">{{description}}</p>
    <p class="description">{{firstGreeting}}</p>

    <button @click="$emit('sayHello', 'ilham')">Say Hello</button>

    <button @click="$emit('sayGoodbye', 'ilham')">Say Goodbye</button>

    <slot name="myheader">
      <p>I am Header</p>
    </slot>
    <slot>
      <p>I am content</p>
    </slot>

  </div>

  Link: https://vuejs.org/guide/components/slots.html#named-slots

  28) Provide / Inject - useContext kimidir Reactda ki. Bir-bir propslarla child to child
  oturmekdense, parentden butun child komponentlere paylayiriq.

  parent component

  <script>
    // provide
    import { provide, reactive } from 'vue'

    // iki parametr qebul edir, injection key 1-ci olan keydir, ikinci ise value.Ikinci
    // teref reactive state de ola biler, her hansi bir sey
    const mes = reactive({ value: 'hello ilham' });
    provide('hello', mes);
  </script>

  child component

  <script>
    // bele inject edirik, inject key ile, 'default value' uygun inject key tapilmadiga 
    // calisir
    import { inject, reactive } from 'vue'

    const message = inject('hello', 'default value')

    const changeMes = () => {
      message.value = 'hello Bro'
    }
  </script>

  <p>{{ mes.value }}</p>

  child da ref deyisdirmek istesen bunu funksiya atmaq ile et

  <script setup>
    const mes = ref('hello ilham');

    provide('hello', {
      value: mes,
      update: updateData
    });

  </script>

  childda

  <script setup>
    // bele inject edirik, inject key ile
    import { inject, reactive } from 'vue'

    const message = inject('hello', 'default value')

  </script>

  <h3>{{ message.value }}</h3>
  <button @click="message.update()">Change Message</button>

  <script setup>
    import { provide, ref } from 'vue'

    const location = ref('North Pole')

    function updateLocation() {
      location.value = 'South Pole'
    }

    provide('location', {
      location,
      updateLocation
    })
  </script>

  child da deyismemeyini istesen readonly() arasinda oturursen

  <script setup>
    import { ref, provide, readonly } from 'vue'

    const count = ref(0)
    provide('read-only-count', readonly(count))
  </script>

  Link: https://vuejs.org/guide/components/provide-inject.html#provide

  29) Async Components - ansinxron olaraq yuklenen komponentler ucundurler.Lazim olduqda
  komponent yuklenir ve sehifenin initial yuklenmesini azaldir.Next dynamic kimidir bir nov.
  Reactda ki lazy ve suspensenin evezidir.

  #error - error ucun, #fallback yuklenme ucun, #default ise ozu ucun istifade olunur.Bunlar
  Suspense ucundurler ve v-slot qisalma formasidir buna gore Suspensenin slotu adlanirlar.

  <script setup lang="ts">

    import { defineAsyncComponent, Suspense } from 'vue';

    const Card02 = defineAsyncComponent(() =>
      import('../components/cards/Card02.vue')
    );

  </script>

  iki componente ayri loader qoymaq isteyirikse iki ayri suspense istifade edirik.

  <Suspense>
    <template #default>
      <Card02 name="Hello World" description="Desc" first-greeting="Hellooo" @say-hello="sayHello"
        @say-goodbye="sayGoodbye">

        <p>I am slot</p>

        <template #myheader>
          <p>I am first header</p>
        </template>

      </Card02>
    </template>
    <template #fallback>
      <p>Loading......</p>
    </template>
  </Suspense>

  <Suspense>
    <template #default>
      <AnotherComponent />
    </template>
    <template #fallback>
      <p>Another Loading......</p>
    </template>
    <template #error>
      <!-- This content will be displayed if there's an error while loading -->
      <div>Error loading component.</div>
    </template>
  </Suspense>

  Suspense ile birlikde istifade oluna bilir.

  Suspensenin iki slotu var: #default ve #fallback, defolt ozudur, yuklenme aninda ise fallback gelir.

  Suspense ile birlikde istifade olunur, loaderi gostermek ucun.

  Link: https://vuejs.org/guide/components/async.html
  Suspense Link: https://vuejs.org/guide/built-ins/suspense.html

  30) Tailwind -

  install edirik -

  npm install tailwindcss postcss autoprefixer

  config fayli yaradiriq -

  npx tailwindcss init -p

  bu fayli yarat esas hissede

  postcss.config.js

  icini bele doldur -

  module.exports = {
  purge: ['./src/**/*.{vue,js,ts,jsx,tsx}'], // Adjust the paths to match your project structure
  darkMode: false, // or 'media' or 'class'
  theme: {
  extend: {},
  },
  variants: {
  extend: {},
  },
  plugins: [],
  };


  Bunlari main css e import et

  @import 'tailwindcss/base';
  @import 'tailwindcss/components';
  @import 'tailwindcss/utilities';

  31) Vue ve Vite ferqi -


  32) Custom Lifecycle Hook yaratma -

  hooks/useCustomLifecycle.ts yarat

  <script>
    import { ref, reactive, onMounted, onBeforeUnmount, Ref } from 'vue';

    interface CustomData {
      message: string;
    }

    export function useCustomLifecycle() {
      const counter: Ref<number> = ref(0);
      const data: CustomData = reactive({
        message: 'Hello from custom lifecycle hook',
      });

      onMounted(() => {
        console.log('Component mounted');
        increaseCounter();
        logMessage();
      });

      onBeforeUnmount(() => {
        console.log('Component unmounted');
      });

      const increaseCounter = () => {
        counter.value++;
      };

      const logMessage = () => {
        console.log(data.message);
      };

      return {
        counter,
        data,
      };
    }

  </script>

  komponentde istifadesi:

  <script>
    import { useCustomLifecycle } from '../../hooks/useCustomLifecycle';
    const { counter, data } = useCustomLifecycle();
  </script>

  33) composables - bunlar funksiyalardir (composable function).Bunlar custom hooklardir.
  Sadece composable functions adlanir. Kod daha qisa olur, bu halda funksiya ve yaxud
  datalar diger komponentlerde de reusable ola bilir.Bildiyimiz adi hook mentiqidir,
  bunlar bize funksiya ve yaxud deyerlerden ibaret obyekt return edir ve her bir komponentde
  cagirib yeniden istifade ede bilirik.

  Mentiqi Reactda olan custom hook ile tamamile eynidir, lakin burada composables adlanirlar.

  <script>
    // mouse.js
    import { ref, onMounted, onUnmounted } from 'vue'

    // by convention, composable function names start with "use"
    export function useMouse() {
      // state encapsulated and managed by the composable
      const x = ref(0)
      const y = ref(0)

      // a composable can update its managed state over time.
      function update(event) {
        x.value = event.pageX
        y.value = event.pageY
      }

      // a composable can also hook into its owner component's
      // lifecycle to setup and teardown side effects.
      onMounted(() => window.addEventListener('mousemove', update))
      onUnmounted(() => window.removeEventListener('mousemove', update))

      // expose managed state as return value
      return { x, y }
    }
  </script>

  Bele de istifade ede bilerik:

  <script>

    import { onMounted, onUnmounted } from 'vue'

    export function useEventListener(target, event, callback) {
      // if you want, you can also make this
      // support selector strings as target
      onMounted(() => target.addEventListener(event, callback))
      onUnmounted(() => target.removeEventListener(event, callback))
    }

  </script>

  Bu halda obyekt qaytarmir, ozu qayidir.Buna gore ozunu birbasa cagirib istifade edirik.

  <script>
    // mouse.js
    import { ref } from 'vue'
    import { useEventListener } from './event'

    export function useMouse() {
      const x = ref(0)
      const y = ref(0)

      useEventListener(window, 'mousemove', (event) => {
        x.value = event.pageX
        y.value = event.pageY
      })

      return { x, y }
    }

  </script>

  Data almaq ucun de istifade ede bilerik:

  <script>

    // fetch.js
    import { ref } from 'vue'

    export function useFetch(url) {
      const data = ref(null)
      const error = ref(null)

      fetch(url)
        .then((res) => res.json())
        .then((json) => (data.value = json))
        .catch((err) => (error.value = err))

      return { data, error }
    }

  </script>

  <script setup>
    import { useFetch } from './fetch.js'

    const { data, error } = useFetch('...')
  </script>

  Link: https://vuejs.org/guide/reusability/composables.html#mouse-tracker-example

  34) custom directives - custom directiveler yazmaq ucun istifade olunurlar.

  oz numunem: Deyer oturmek ile

  <script>
    // custom directive
    const vBackground = {
      mounted: (el: any, binding: any) => el.style.backgroundColor = binding.value || 'red'
    }
  </script>

  <p v-background="'blue'">Background</p>

  numunem: app seviyesind

  <script>
    app.directive('myColor', (el, binding) => {
      el.style.color = binding.value || 'white';
    })
  </script>

  <p v-background="'blue'" v-my-color="'yellow'">Background</p>


  <script setup>
    // enables v-focus in templates
    const vFocus = {
      mounted: (el) => el.focus()
    }
  </script>

  <template>
    <input v-focus />
  </template>

  app seviyyesinde de directiveler yazmaq olar:

  <script>
    const app = createApp({})

    // make v-focus usable in all components
    app.directive('focus', {
      /* ... */
    })
  </script>

  Ala bileceyi hook funksiyalari

  <script>
    const myDirective = {
      // called before bound element's attributes
      // or event listeners are applied
      created(el, binding, vnode, prevVnode) {
        // see below for details on arguments
      },
      // called right before the element is inserted into the DOM.
      beforeMount(el, binding, vnode, prevVnode) { },
      // called when the bound element's parent component
      // and all its children are mounted.
      mounted(el, binding, vnode, prevVnode) { },
      // called before the parent component is updated
      beforeUpdate(el, binding, vnode, prevVnode) { },
      // called after the parent component and
      // all of its children have updated
      updated(el, binding, vnode, prevVnode) { },
      // called before the parent component is unmounted
      beforeUnmount(el, binding, vnode, prevVnode) { },
      // called when the parent component is unmounted
      unmounted(el, binding, vnode, prevVnode) { }
    }
  </script>

  Link: https://vuejs.org/guide/reusability/custom-directives.html

  35) Transition: 

  Link: https://vuejs.org/guide/built-ins/transition.html

  36) 






</body>

</html>